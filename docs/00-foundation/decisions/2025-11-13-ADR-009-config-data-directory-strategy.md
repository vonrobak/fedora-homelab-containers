# Configuration vs Data Directory Strategy

**Date:** 2025-11-13
**Status:** Accepted
**Decision Maker:** Claude Code (with user approval)

---

## Context

Some containerized services (notably CrowdSec) store configuration files in directories that also contain runtime data and secrets. This creates a tension between:

1. **Design Principle:** Configs in `~/containers/config/` (git-tracked), data in `~/containers/data/` (gitignored)
2. **Runtime Reality:** Services like CrowdSec modify their config at runtime and expect writable `/etc` directories

**Specific Case: CrowdSec**
- Container mounts: `~/containers/data/crowdsec/config` → `/etc/crowdsec`
- Contains: Custom configs (profiles.yaml, acquis.yaml, whitelists) + secrets (API credentials) + hub downloads
- All intermixed in the same directory tree

---

## Decision

**Adopted Alternative 1: Selective Gitignore Exceptions**

Keep configuration files in `data/` directory where services expect them, but use gitignore exceptions to selectively track custom configs while excluding secrets and generated files.

---

## Alternatives Considered

### Alternative 1: Selective Gitignore Exceptions ✅ CHOSEN
**Approach:** Use gitignore patterns to track specific custom configs within data/

**Implementation:**
```gitignore
data/*  # Ignore everything in data/

# But un-ignore CrowdSec custom configs
!data/crowdsec/
!data/crowdsec/config/
!data/crowdsec/config/profiles.yaml
!data/crowdsec/config/acquis.yaml
!data/crowdsec/config/parsers/s02-enrich/local-whitelist.yaml

# Re-ignore everything else (secrets, hub downloads, etc.)
data/crowdsec/config/*
!data/crowdsec/config/profiles.yaml
!data/crowdsec/config/acquis.yaml
data/crowdsec/config/parsers/s02-enrich/*
!data/crowdsec/config/parsers/s02-enrich/local-whitelist.yaml
```

**Pros:**
- Minimal disruption - no file moves or quadlet changes
- Custom configs tracked in git (version control, disaster recovery)
- Secrets remain gitignored (secure)
- Services work unchanged (configs where they expect them)

**Cons:**
- Violates config/ vs data/ design principle
- Gitignore complexity (many patterns, order matters)
- Future maintainers might find it confusing
- Easy to accidentally commit secrets if patterns are wrong

### Alternative 2: Config/Data Split with Symlinks ❌ REJECTED
**Approach:** Move configs to `config/`, create symlinks from `data/` back to `config/`

**Why Rejected:**
- Symlinks with absolute paths don't work inside containers
- Symlinks with relative paths are complex to maintain
- Container filesystems can't resolve paths outside their mounts
- Testing revealed CrowdSec couldn't read symlinked configs
- Would require additional volume mounts in quadlet

**Attempted Implementation Failed:**
```bash
# This didn't work
ln -s ~/containers/config/crowdsec/profiles.yaml \
      ~/containers/data/crowdsec/config/profiles.yaml
# Container error: "open /etc/crowdsec/profiles.yaml: no such file or directory"
```

### Alternative 3: ConfigMaps Pattern ❌ TOO COMPLEX
**Approach:** Template-based config generation (Kubernetes-style)

**Why Rejected:**
- Significant refactoring effort (templates + rendering script)
- Overkill for single-instance homelab
- Adds complexity without proportional benefit
- Harder to debug (must check template + rendered output)

---

## Rationale

**Why Alternative 1 wins:**

1. **Pragmatism over Purity:** Design principles are guidelines, not laws. When runtime constraints conflict with principles, pragmatic solutions are acceptable with clear documentation.

2. **Low Risk:** Gitignore exceptions are well-understood and testable. Git operations remain fast.

3. **Maintainability:** With clear documentation (this ADR + gitignore comments), future maintainers will understand the reasoning.

4. **Proven Pattern:** Many projects use gitignore exceptions for similar cases (e.g., tracking specific files in otherwise-ignored directories).

---

## Implementation

### Files Tracked in data/

**CrowdSec Custom Configs:**
- `data/crowdsec/config/profiles.yaml` - Custom ban profiles (tiered strategy per ADR-008)
- `data/crowdsec/config/acquis.yaml` - Log acquisition configuration
- `data/crowdsec/config/parsers/s02-enrich/local-whitelist.yaml` - Local network whitelist

**Still Ignored (Secrets):**
- `data/crowdsec/config/local_api_credentials.yaml` - API keys
- `data/crowdsec/config/online_api_credentials.yaml` - CAPI credentials
- `data/crowdsec/config/*credentials*.yaml` - Any other credential files

**Still Ignored (Generated/Large):**
- `data/crowdsec/config/hub/` - Downloaded scenarios, parsers (regenerable)
- All other files in data/ (databases, logs, temp files)

### OCIS Handling

**Decision:** Do NOT track `config/ocis/ocis.yaml`

**Rationale:**
- Generated by `ocis init` (not hand-written)
- Contains instance-specific UUIDs
- Secrets handled via Podman secrets (not in file)
- File owned by container UID with mode 600 (not user-readable)

**Added to gitignore:**
```gitignore
# OCIS Generated Config (instance-specific, created by 'ocis init')
config/ocis/ocis.yaml
```

**What IS tracked:**
- `quadlets/ocis.container` - Quadlet definition ✅
- `config/traefik/dynamic/ocis-router.yml` - Routing config ✅
- `docs/10-services/guides/ocis.md` - Documentation ✅

---

## Testing

**Verification Commands:**
```bash
# Test gitignore is working
git check-ignore -v data/crowdsec/config/profiles.yaml
# Should output pattern that un-ignores it

# Preview what would be added
git add -n data/crowdsec/config/
# Should show: profiles.yaml, acquis.yaml, local-whitelist.yaml
# Should NOT show: credentials files, hub/, other configs

# Verify secrets still ignored
git check-ignore -v data/crowdsec/config/local_api_credentials.yaml
# Should show it's ignored
```

**Test Results:**
- ✅ Custom configs tracked (3 files)
- ✅ Secrets excluded (2 credential files)
- ✅ CrowdSec service operational after gitignore changes
- ✅ No performance impact on git operations

---

## Consequences

### Positive

1. **Version Control:** Custom configs now tracked, can see history of changes
2. **Disaster Recovery:** Configs backed up via git, can restore from any commit
3. **Documentation:** This ADR explains the reasoning for future maintainers
4. **Minimal Disruption:** Services continue working unchanged

### Negative

1. **Principle Violation:** configs in data/ (documented and accepted)
2. **Gitignore Complexity:** 15+ lines of patterns instead of simple `data/*`
3. **Maintenance Burden:** Future configs need similar exception patterns
4. **Accidental Commits Risk:** Mitigated by explicit re-ignore patterns for secrets

---

## Review Schedule

**Next Review:** When migrating to new services with similar constraints

**Review Criteria:**
- Has gitignore complexity become unmanageable?
- Have we accidentally committed secrets?
- Are there better solutions available (e.g., Podman secrets for all configs)?

---

## References

- **Configuration Design Principles:** `/docs/00-foundation/guides/configuration-design-quick-reference.md`
- **CrowdSec Crash Loop Fix:** Session 2025-11-13 (whitelist CIDR syntax)
- **Gitignore Documentation:** https://git-scm.com/docs/gitignore
- **Alternative Analysis:** This document (see "Alternatives Considered")

---

**Conclusion:** This is a pragmatic solution to a real constraint. While it violates the ideal design principle, it's well-documented, low-risk, and maintainable. The trade-off (principle purity vs operational simplicity) is worth it for this homelab context.
